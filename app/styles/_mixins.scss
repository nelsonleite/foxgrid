/**
 * Base style and gutter for columns
 */
@mixin make-grid-columns($_gutter: true) {
    flex: 1 0 auto;

    @if ($_gutter == true) {
        @each $breakpoint, $val in $breakpoints {
            @if $val == '' {
                @include calc-column-gutter('padding', $breakpoint);
            }
            @else {
                @media (min-width: #{$val}) {
                    @include calc-column-gutter('padding', $breakpoint);
                }
            }
        }
    }
}

/**
 * Calculate gutter width
 * @param  $property    Property to apply the value
 * @param  $breakpoint
 * @param  $abs         [1, -1] Whether the $property value is positive or negative
 */
@mixin calc-column-gutter($property, $breakpoint, $abs: 1) {
    #{$property}-right: floor(((map-get($gutter-map, #{$breakpoint}) * $abs) / 2)) + px;
    #{$property}-left: ceil(((map-get($gutter-map, #{$breakpoint}) * $abs) / 2)) + px;
}

/**
 * Calculate properties for each column
 * @param $breakpoint
 * @param $type [width, offset] Property name
 */
@mixin calc-grid-column($_breakpoint: $first-breakpoint, $_type: 'width', $_grid-columns: $grid-columns) {
    @for $i from 1 through $_grid-columns {
        // width
        @if ($_type == 'width') {
            // first breakpoint: avoid specifying column breakpoint
            @if ($first-breakpoint == $_breakpoint) {
                .col-#{$i} {
                    flex-basis: percentage($i / $_grid-columns);
                    max-width: percentage($i / $_grid-columns);
                }
            }

            // regular breakpoint columns
            .col-#{$_breakpoint}-#{$i} {
                flex-basis: percentage($i / $_grid-columns);
                max-width: percentage($i / $_grid-columns);
            }
        }

        // offsets
        @if ($_type == 'offset') {
            @if ($first-breakpoint == $_breakpoint) {
                .col-offset-#{$i} {
                    margin-left: percentage($i / $_grid-columns);
                }
            }

            .col-#{$_breakpoint}-offset-#{$i} {
                margin-left: percentage($i / $_grid-columns);
            }
        }
    }
}

/**
 * Mixin to avoid code duplication, once it is used with and
 * without media queries
 */
@mixin loop-breakpoints() {
    //
    // width
    //
    @include calc-grid-column($breakpoint);

    //
    // offset
    //
    @include calc-grid-column($breakpoint, 'offset');

    //
    // order
    //
    .col-#{$breakpoint}-first { order: -1; }
    .col-#{$breakpoint}-last { order: 1; }

    //
    // alignments
    //
    .align-start-#{$breakpoint} {
        justify-content: flex-start;
        &.align-text { text-align: start; }
    }
    .align-center-#{$breakpoint} {
        justify-content: center;
        &.align-text { text-align: center; }
    }
    .align-end-#{$breakpoint} {
        justify-content: flex-end;
        &.align-text { text-align: end; }
    }

    .align-top-#{$breakpoint} { align-items: flex-start; }
    .align-middle-#{$breakpoint} { align-items: center; }
    .align-bottom-#{$breakpoint} { align-items: flex-end; }

    .stretch-#{$breakpoint} {
        align-items: stretch;

        > [class*="col"] {
            display: flex;
        }
    }

    //
    // self alignments
    //
    .align-self-top-#{$breakpoint} {
        align-self: flex-start;
    }

    .align-self-middle-#{$breakpoint} {
        align-self: center;
    }

    .align-self-bottom-#{$breakpoint} {
        align-self: flex-end;
    }

    .self-stretch-#{$breakpoint} {
        display: flex;
        align-self: stretch;
    }

    //
    // distribute
    //
    .space-around-#{$breakpoint} {
        justify-content: space-around;
    }

    .space-between-#{$breakpoint} {
        justify-content: space-between;
    }
}

/**
 * Semantic row
 */
@mixin grid-row($_gutter: true) {
    display: flex;
    flex: 0 1 auto;
    flex-direction: row;
    flex-wrap: wrap;

    // gutter margins
    @if ($_gutter == true) {
        @include grid-row-gutter-margins();
    }
}

/**
 * Semantic row margins
 */
@mixin grid-row-gutter-margins() {
    // gutter margins
    @each $breakpoint, $val in $breakpoints {
        @if $val == '' {
            @include calc-column-gutter('margin', $breakpoint, -1);
        }
        @else {
            @media (min-width: #{$val}) {
                @include calc-column-gutter('margin', $breakpoint, -1);
            }
        }
    }
}

/**
 * Semantic columns
 */
@mixin grid-column($_count, $_gutter: true, $grid-columns: $grid-columns) {
    @include make-grid-columns($_gutter);

    flex-basis: percentage($_count / $grid-columns);
    max-width: percentage($_count / $grid-columns);
}

/**
 * Removing list value at nth index
 * @param  {list} $list  List to remove the item
 * @param  {list} $index Index for the item to be removed
 * @return {list}        List with the item removed
 */
@function remove-nth($list, $index) {
    $result: null;

    @if type-of($index) != number {
        @warn "$index: #{quote($index)} is not a number for `remove-nth`.";
    }

    @else if $index == 0 {
        @warn "List index 0 must be a non-zero integer for `remove-nth`.";
    }

    @else if abs($index) > length($list) {
        @warn "List index is #{$index} but list is only #{length($list)} item long for `remove-nth`.";
    }

    @else {
        $result: ();
        $index: if($index < 0, length($list) + $index + 1, $index);

        @for $i from 1 through length($list) {
            @if $i != $index {
                $result: append($result, nth($list, $i));
            }
        }
    }

    @return $result;
}

